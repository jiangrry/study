[TOC]

# 函数和存储过程

存储过程和函数是事先经过编译并存储在数据库中的一段sql语句集合，调用存储过程和函数可以简化应用开发工作，提高数据处理的效率。

## 函数和存储过程区别

1. 函数有且只有一个返回值，而存储过程不能有返回值。
2.  函数只能有输入参数，而存储过程可以有`in,out,inout`多个类型参数。
3. 存储过程中的语句功能更丰富，实现更复杂的业务逻辑，而函数中通常不会使用`insert,update,delete`等语句，只是完成查询的工作，受输入参数并返回一个结果，功能针对性比较强。
4. 存储过程一般是作为一个独立的部分来执行(`call`调用)。而函数可以作为查询语句的一个部分来调用.

## 创建函数

```MYSQL
delimiter 自定义符号 -- 自定义函数结尾符号 通常 // $$
create function 函数名(形参列表) returns 返回类型 
    -- 一个库下面 函数名不能重复 
    -- 形参 (a int, b float)
begin
	函数体;
	return val;
end  自定义符号 -- // $$ 
delimiter ;
```

### 释义：

- `delimiter` 自定义符号 是为了在函数内些语句方便，制定除了;之外的符号作为函数书写结束标志,一般用`$$`或者`//`
- 形参列表 ： 形参名 类型   类型为`mysql`支持类型
- 返回类型:  函数返回的数据类型,`mysql`支持类型即可
- 函数体： 若干`sql`语句组成，如果只有一条语句也可以不写`delimiter`和`begin,end`
- `return`: 返回指定类型返回值

## 创建存储过程

```MYSQL
delimiter 自定义符号　
create procedure 存储过程名(形参列表)
begin
	存储过程　　　
end  自定义符号
delimiter ;

```

### 释义

- `delimiter` 自定义符号 是为了在函数内些语句方便，制定除了`;`之外的符号作为函数书写结束标志
- 形参列表 ：`[ IN | OUT | INOUT ] `形参名 类型
              ` in` 输入，`out`  输出，`inout` 可以输入也可以输出
- 存储过程： 若干`sql`语句组成，如果只有一条语句也可以不写`delimiter`和`begin,end`

### 参数类型

存储过程三个参数的区别

- `IN` 类型参数可以接收变量也可以接收常量，传入 的参数在存储过程内部使用即可，但是在存储过程内部的修改无法传递到外部。
- `OUT` 类型参数只能接收一个变量，接收的变量不能够在存储过程内部使用（内部为`NULL`），但是可以在存储过程内对这个变量进行修改。因为定义的变量是全局的，所以外部可以获取这个修改后的值。
- `INOUT`类型参数同样只能接收一个变量，但是这个变量可以在存储过程内部使用。在存储过程内部的修改也会传递到外部。

### 创建变量

用户变量方法：   
	set  @[变量名] = 值； 表示这是一个用户变量，使用时用@[变量名]。 

局部变量方法：
     在函数内部设置declare [变量名] [变量类型]为局部变量，局部变量可以使用set赋值或者着使用into关键字。

### 使用函数和存储过程

1. 调用存储过程
   语法：call 存储过程名字（[存储过程的参数[,……]])

   

2. 调用存储函数
   语法：select 存储函数名字（[存储过程的参数[,……]])

   

3. 使用show status语句查看存储过程和函数的信息
   语法：show {procedure|function} status [like’存储过程或存储函数的名称’]
   显示内容：数据库、名字、类型、创建者、创建和修改日期

   

4. 使用show create语句查看存储过程和函数的定义
   语法：show create  {procedure|function}  存储过程或存储函数的名称

5. 删除存储过程或存储函数
   语法：DROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name

## 案例：编写函数和存储过程

使用`cls`表完成

- 编写一个函数，传入两个参数，分别是两个记录id 返回两个人的分数之差
- 编写一个存储过程，传入学生id，通过out类型的参数 返回到这个学生的年龄

# 事务控制

## 事务概述

定义 ： 一件事从开始发生到结束的过程，数据库事务通常指对数据库进行读或写的一个操作序列。

MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，如果操作就必须同时操作成功，如果有一个不成功则所有数据都不动。这时候数据库操作语句就构成一个事务。事务主要处理数据的增删改操作。

## 作用

事务的存在包含有以下两个目的：

1. 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

## 四大特征

1. 原子性（atomicity）
一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作
2. 一致性（consistency）
事务完成时，数据必须处于一致状态，数据的完整性约束没有被破坏，事务在执行过程中发生错误，则回到事务开始前的状态，就像这个事务从来没有执行过一样。

3. 隔离性（isolation）
   一个事务所做的修改在最终提交以前，对其他事务是不可见的。多个事务相互独立。
4. 持久性（durability）
   一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

## 事务操作

```mysql
-- 1. 开启事务
begin; # 方法1
start transaction; # 方法2

-- 2. 开始执行事务中的1条或者n条SQL命令

-- 3. 终止事务，若begin之后没有commit，而是使用其他语句，比如select，那么会自动commit，修改直接生效。
mysql>commit; # 事务中SQL命令都执行成功,提交到数据库,结束!
mysql>rollback; # 有SQL命令执行失败,回滚到初始状态,结束!
```

## 隔离特征

####  事务隔离级别

事务四大特性中的隔离性是在使用事务时最为需要注意的特性，因为隔离级别不同带来的操作现象也有区别

隔离级别

- 读未提交：read uncommitted

  > 事物A和事物B，事物A未提交的数据，事物B可以读取到
  >
  > 这里读取到的数据叫做“脏数据”
  >
  > 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别

- 读已提交：read committed

  > 事物A和事物B，事物A提交的数据，事物B才能读取到
  > 这种隔离级别高于读未提交
  > 换句话说，对方事物提交之后的数据，我当前事物才能读取到
  > 这种级别可以避免“脏数据”
  > 这种隔离级别会导致“不可重复读取”

- 可重复读：repeatable read

  > 事务A和事务B，事务A提交之后的数据，事务B读取不到
  > 事务B是可重复读取数据
  > 这种隔离级别高于读已提交
  > MySQL默认级别
  > 虽然可以达到可重复读取，但是会导致“幻像读”

- 串行化：serializable

  > 事务A和事务B，事务A在操作数据库时，事务B只能排队等待
  > 这种隔离级别很少使用，吞吐量太低，用户体验差
  > 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发

# 数据库优化

## 范式思想

设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式。

> 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。

## 三范式

- 第一范式： 数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等组合的数据项。简单来说要求数据库中的表示二维表，每个数据元素不可再分。
- 第二范式： 第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分，所有属性依赖于主属性。即选取一个能区分每个实体的属性或属性组，作为实体的唯一标识，每个属性都能被主属性筛选。
- 第三范式： 在第二范式的基础上属性不传递依赖，即每个属性于其它非主属性。要求一个关系中不包含已在其它关系已包含的非主关键字信息。

## 存储引擎

### 什么是存储引擎

定义： mysql数据库管理系统中用来处理表的处理器

基本操作：

- 查看所有存储引擎   show engines;
- 查看已有表的存储引擎   show create table 表名;
- 创建表指定  create table 表名(...)engine=MyISAM,charset=utf8;
- 已有表指定   alter table 表名 engine=InnoDB;

### 常见mysql引擎 

#### `InnoDB`

1. 支持行级锁,仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。
2. 支持外键、事务、事务回滚
3. 表字段和索引同存储在一个文件中   

####  `MyISAM`

1. 不支持事务
2. 表级锁定
3. 读写互相阻塞
4. 只会缓存索引        
5. 读取速度较快，占用资源相对较少

### MYSQL 引擎选择

MyISAM：应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高。MyISAM是在Web、数据仓库和其他应用环境下最常使用的存储引擎之一。

InnoDB：用于事务处理应用程序，支持外键。应用程序对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询外，还包括很多的更新、删除操作。InnoDB存储引擎除了有效地降低由于删除和更新导致地锁定，还可以确保事务地完整提交(Commit)和回滚(Rollback)，对于类似计费系统或者财务系统等对数据准确性要求较高地系统，InnoDB都是合适地选择。

## 语句优化

### SQL 语句优化

- 尽量选择数据类型占空间少，在where ，group by，order by中出现的频率高的字段建立索引。
- explain 放在查询语句前面可以获取查询计划，建立合适索引
- 尽量避免使用 select * ...;用具体字段代替 * ,不要返回用不到的任何字段。
- 少使用like %查询，否则会全表扫描
- 子查询优化为join查询
- 控制使用自定义函数。
- 单条查询最后添加 LIMIT 1，停止全表扫描
- where子句中不使用 != ,否则放弃索引全表扫描
- 尽量避免 NULL 值判断,否则放弃索引全表扫描，在number列上设置默认值0,确保number列无NULL值
      优化前：select number from t1 where number is null; 
      优化后：select number from t1 where number=0; 
- 尽量避免 or 连接条件,否则放弃索引全表扫描，可以用union代替  
     优化前：select id from t1 where id=10 or id=20;  
     优化后： select id from t1 where id=10 union all             select id from t1 where id=20;
- 尽量避免使用 in 和 not in,否则全表扫描 
    优化前：select id from t1 where id in(1,2,3,4); 
    优化后：select id from t1 where id between 1 and 4;

### 其他优化方法

#### 字段数据类型选择

- 优先程度   数字 >  时间日期 > 字符串
- 同一级别   占用空间小的 > 占用空间多的
- 少于50字节 char > varchar
- 对数据存储精确不要求 float > decimel
- 如果很少被查询可以用 TIMESTAMP（时间戳实际是整形存储）

#### 键的设置

- Innodb如果不设置主键也会自己设置隐含的主键，所以最好自己设置
- 尽量设置占用空间小的字段为主键。
- 外键的设置用于保持数据完整性，但是会降低数据导入和操作效率，特别是高并发情况下，而且会增加维护成本。
- 虽然高并发下不建议使用外键约束，但是在表关联时建议在关联键上建立索引，以提高查找速度。

#### explain 语句

使用 EXPLAIN 关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。 
e.g.： explain select * from class_1 where id <5;
通过explain命令可以得到:

- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用， 哪些索引被实际使用
- 表之间的引用， 每张表多少行被优化器查询

EXPLAIN主要字段解析：

- table：显示这一行的数据是关于哪张表的
- type：这是最重要的字段之一，显示查询使用了何种类型。从最好到最差的连接类型为system、const、eq_reg、ref、range、index和ALL。
- possible_keys：显示可能应用在这张表中的索引。如果为空，表示没有可能应用的索引。
- key：实际使用的索引。如果为NULL，则没有使用索引。
- rows：MySQL认为必须检索的用来返回请求数据的行数

#### 表的拆分

- 垂直拆分 ： 表中列太多，分为多个表，每个表是其中的几个列。将常查询的放到一起，blob或者text类型字段放到另一个表。
- 水平拆分 ： 减少每个表的数据量，通过hash key进行划分然后拆成多个表。