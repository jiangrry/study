[TOC]
# 1.套接字

## 1.1 套接字简介

1982 - Berkeley Software Distributions操作系统引入了socket作为本地进程之间通信的接口。1986 - Berkeley 扩展了`socket `接口，使之支持`UNIX` 下的`TCP/IP` 通信

现在很多应用 (FTP, Telnet, etc) 都依赖这一接口，而且这种接口是独立于网络协议的。在`linux`系统下`socket`还是一种特殊的文件描述符。通过`socket`形成的网络通信并不仅限于`TCP/IP`协议。普通的`I/O`操作是打开文件，读写操作，关闭文件，而通过`socket TCP/IP`协议被集成到了操作系统的内核中，引入了新型`“I/O”`操作。

## 1.2 应用层套接字类型

-   流式套接字(SOCK_STREAM)

    提供了一个面向连接、可靠的数据传输服务，数据无差错、无重复的发送且按发送顺序接收。内设置流量控制，避免数据流淹没慢的接收方。数据被看作是字节流，无长度限制。

-   数据报套接字(SOCK_DGRAM)

    提供无连接服务。数据包以独立数据包的形式被发送，不提供无差错保证，数据可能丢失或重复，顺序发送，可能乱序接收。

# 2. 流失套接字

## 2.1 TCP 服务端

### 2.1.1 TCP 套接字服务端流程

<img src="./img/1_TCP_Server.png"  />

### 2.1.2 TCP 套接字服务端函数

- 创建套接字

```python
sockfd = socket.socket(socket_family, socket_type, proto=0)
功能：创建套接字
参数：socket_family  网络地址类型 AF_INET 表示 ipv4
	 socket_type  套接字类型 SOCK_STREAM 表示tcp套接字 （也叫流式套接字） 
	 proto  通常为0  选择子协议
返回值： 套接字对象
```

- 绑定地址 

```python
sockfd.bind()
功能 ： 绑定地址
参数 ： 一个元组包含两项 ，第一项为IP第二项为端口号
        例如   （'172.60.50.50',8888）
```

* 设置监听

```python
sockfd.listen(n)
功能 ： 
	将套接字设置为监听套接字
    创建监听队列，并且设置监听队列的大小。
参数 ： n是一个正整数 表示监听等待队列的大小
```

![](./img/11.jpg)

* 处理客户端连接请求

```python
connfd,addr = sockfd.accept()
功能： 
	阻塞等待处理客户端请求
返回值： 
	第一个 ： 一个新的套接字用来和客户端通信
	第二个 ： 连接的客户端的地址
    sockfd: 负责监听、处理链接
    connfd: 负责与客户端进行交互通信
```

* 消息收发

```python
data = connfd.recv(buffersize)
功能 ： 流式套接字接收消息
参数 ： 一次最多接收多大的消息  字节
返回值 ： 返回接收到的内容


n = connfd.send(data)
功能 ： 流式套接字发送消息
参数 ： 要发送的内容  要求bytes格式
返回值 ： 返回实际发送的字节数
```

>   `close`会将套接字销毁，会断开。

-   关闭套接字 (与udp套接字相同)

```python
sockfd.close（）
功能：关闭套接字 tcp套接字连接断开
```

## 2.2 TCP客户端

### 2.2.1 TCP套接字客户端流程

![](./img/1_TCP_Client.png)

### 2.2.2 TCP 套接字客户端流程

1.  创建TCP套接字

2.  请求连接

    ```python
    sockfd.connect(server_addr)
    	功能：连接服务器
    	参数：元组  服务器地址
    ```

3.  收发消息

    >   注意： 防止两端都阻塞，`recv send`要配合

4.  关闭套接字

### 练习

>   ```python
>   编写一个服务端和客户端，从客户端将一个文件上传给服务端，注意文件类型可以为文本也可以是二进制文件。
>   ```
>

![](./img/12.png)



## 2.3 TCP 套接字细节处理

##### 2.3.1 网络缓冲区

-   每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。

-   send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负搜索责的事情。

-   recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。

![](./img/13.jpg)

### 2.3.2 TCP粘包

-   原因：
    * 为了解决数据再传输过程中可能产生的速度不协调问题，操作系统设置了缓冲区
    * 实际网络工作过程比较复杂，导致消息收发速度不一致
    * tcp以字节流方式进行数据传输，在接收时不区分消息边界

-   影响：

    如果每次发送内容是一个独立的含义，需要接收端独立解析此时粘包会有影响。

-   **处理方法**

    1.  人为的添加消息边界

    2.  控制发送速度

### 2.3.3 套接字属性

```python
套接字对象(s表示一个套接字对象)

s.type：
	获取套接字类型
    
s.family：
	地址类型
    
s.getsockname()
	功能：获取套接字绑定的地址
    
s.getperrname()
	功能：用户连接套接字,获取链接端的地址
    
s.setsockopt(level, optname, value)
功能：设置套接字选项，丰富修改原有套接字功能
参数：
	level：设置选项的类型
    optname：设置类型中的字选项
    value：为选定的选项设置值
```

